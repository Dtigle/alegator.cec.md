@{
    var wacomLicenseKey = System.Web.Configuration.WebConfigurationManager.AppSettings["wacomLicenseKey"];
    var wacomSecret = System.Web.Configuration.WebConfigurationManager.AppSettings["WacomLicenseSecret"];
}

<script type="text/javascript">
    var wacomLicenseKey = '@Html.Raw(wacomLicenseKey)';
    var wacomSecret = '@Html.Raw(wacomSecret)';
</script>

<div class="modal fade" id="signatureDialog" data-backdrop="static" style="top: 100px">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">Semnatura</h4>
            </div>

            <div class="modal-body">
                <div class="well form-horizontal">
                    <div class="row">
                        <div class="col-xs-12 signature-container">
                            <div id="initializeBanground" class="active" style="width:100%;height:100%;position:fixed;background:#cccccccc;">
                                <div style="position:absolute;left:50%;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);">
                                    <table><tr><td><div class="loader"></div></td><td>Initializing, this could take a few seconds...</td></tr></table>
                                </div>
                            </div>
                            <div class="wrapper">
                                <p>
                                    Nume:
                                    <span id="signatureLastName"></span>
                                </p>

                                <p>
                                    Prenume:
                                    <span id="signatureFirstName"></span>
                                </p>

                                <p>
                                    IDNP:
                                    <span id="signatureIdnp"></span>
                                </p>

                                <div id="content_container">
                                    <div id="capture_signature_div" class="tabcontent">
                                        <p>
                                            <button id="capture_stu_btn" onClick="capture('STU')" disabled="disabled">Capture signature from STU tablet</button><br><br>
                                        </p>

                                        <fieldset style="width:0;padding:0;margin:0;">
                                            <div id="captureDiv" style="width:400px;height:226px;"></div>
                                            <img id="signatureImage" style="display:none">
                                        </fieldset>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button type="button" class="btn btn-default cancel-signature-btn" data-dismiss="modal">Anuleaza</button>
                <button type="button" class="btn btn-danger" onclick="resign()">Recaptare</button>
                <button id="saveSignatureBtn" disabled="disabled" type="button" class="btn btn-primary" onClick="saveSignature()">Transmite</button>
            </div>
        </div>
    </div>
</div>

<script src="~/Scripts/signature-sdk/stu-sdk.min.js"></script>  @*used to connect to STU devices*@
<script src="~/Scripts/signature-sdk/aes-ecb.js"></script>  @*utility for STU encryption*@
<script src="~/Scripts/signature-sdk/stu_capture_encryption.js"></script>  @*STU encryption functions*@
<script src="~/Scripts/signature-sdk/signature_sdk.js"></script>  @*signature SDK*@
<script src="~/Scripts/signature-sdk/signature_sdk_helper.js"></script>  @*signature SDK helper*@
<script src="~/Scripts/signature-sdk/browser-report.js"></script>  @*for getting web browser information*@
<script src="~/Scripts/signature-sdk/sigCaptDialog.js"></script>
<script src="~/Scripts/signature-sdk/stuCaptDialog.js"></script>

<script>
    var mSigObj;
    var documentHash;
    var backgroundImage;
    var sigCaptDialog
    var stuCapDialog;

    // This var will store the public and private keys for encryption.
    // Please note that this is only a demostration, but on a production application
    // for security reasons the private key should not be stored in a global variable.
    var encryptionKeys;

    function waitForDOMElement(selector) {
        return new Promise(resolve => {
            if (document.querySelector(selector)) {
                return resolve(document.querySelector(selector));
            }

            const observer = new MutationObserver(mutations => {
                if (document.querySelector(selector)) {
                    observer.disconnect();
                    resolve(document.querySelector(selector));
                }
            });

            // If you get "parameter 1 is not of type 'Node'" error, see https://stackoverflow.com/a/77855838/492336
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        });
    }

    const captureStuBtn = document.getElementById("capture_stu_btn");
    captureStuBtn.parentElement.classList.add("d-none");

    async function initializeSignatureCapturingModule() {
        documentHash = new Module.Hash(Module.HashType.None);
        mSigObj = new Module.SigObj();

        const promise = mSigObj.setLicence(wacomLicenseKey, wacomSecret);

        promise.then(value => {
            if (value) {
                if (navigator.hid) {
                    document.getElementById("capture_stu_btn").disabled = false;
                }

                document.getElementById("initializeBanground").style.display = "none";
            }

            signatureFirstName.innerHTML = document.querySelector("#signatureDialog").dataset.firstName;
            signatureLastName.innerHTML = document.querySelector("#signatureDialog").dataset.lastName;
            signatureIdnp.innerHTML = document.querySelector("#signatureDialog").dataset.idnp;

            captureStuBtn.click();
            startModalCountdown();
        });
        promise.catch(error => {
            alert(error);
            document.getElementById("initializeBanground").style.display = "none";
        });
    }

    Module.onAbort = _ => {
        alert("Web browser not supported");
        document.getElementById("initializeBanground").style.display = "none";
    }

    function generateConfig() {
        const config = {};
        config.strokeSize = 6;
        config.strokeColor = "#0202FE";
        config.width = "400";
        config.height = "300";
        config.left = "0px";
        config.top = "0px";
        config.centered = true;
        config.borderColor = "#0097d4";
        config.borderWidth = "3";

        config.signatory = {
            visible: true,
            fontFace: "Verdana",
            fontSize: 14,
            offsetX: 10,
            offsetY: 0,
            color: "#000000"
        };

        config.reason = {
            visible: true,
            fontFace: "Verdana",
            fontSize: 16,
            offsetX: 5,
            offsetY: 10,
            color: "#000000"
        };

        config.additionalData = {
            visible: true,
            fontFace: "Verdana",
            fontSize: 14,
            offsetX: 10,
            offsetY: 20,
            color: "#000000"
        };

        config.signingLine = {
            visible: true,
            left: 10,
            right: 10,
            width: 2,
            offsetY: 25,
            color: "#D3D3D3"
        };

        config.buttonsFont = "Arial";
        config.buttons = [];
        config.attachTo = "captureDiv";

        config.modal = true;
        config.draggable = true;

        const comboTools = document.getElementById("inking_tool");
        const inkColor = "#0202FE";
        const comboBackgroundMode = document.getElementById("background_image_mode");
        config.background = {
            color: "#ffffff",
            alpha: 100 * 0.01,
            mode: "None"
        };

        config.minTimeOnSurface = 300;

        return config;
    }

    function capture(source) {
        let captureDiv = document.getElementById("captureDiv");

        captureDiv.style.width = "400 px";
        captureDiv.style.height = "400 px";

        document.getElementById("signatureImage").style.display = "none";
        document.getElementById("captureDiv").style.display = "block"

        if (source == "STU") {
            captureFromSTU();
        } else {
            captureFromCanvas();
        }
    }

    function captureFromCanvas() {
        stuCapDialog = null;
        const config = generateConfig();
        config.source = {
            mouse: true,
            touch: true,
            pen: true
        }
        sigCaptDialog = new SigCaptDialog(config);
        sigCaptDialog.addEventListener("ok", function () {
            renderSignature();
        });

        //in this demo we use https://github.com/keithws/browser-report library for getting
        //information about the os.
        const webBrowserData = browserReportSync();
        const osInfo = webBrowserData.os.name + " " + webBrowserData.os.version;
        const digitizerInfo = webBrowserData.browser.name + " " + webBrowserData.browser.version;
        const nicInfo = "";
        const where = "";
        sigCaptDialog.open(mSigObj, "", "", where, Module.KeyType.SHA512, documentHash, osInfo, digitizerInfo, nicInfo);
        sigCaptDialog.startCapture();
    }

    async function captureFromSTU() {
        sigCaptDialog = null;
        const config = generateConfig();

        const stuDeviceStr = localStorage.getItem("stuDevice");
        let stuDevice;
        if (!stuDeviceStr) {
            const devices = await com.WacomGSS.STU.UsbDevice.requestDevices();
            if (devices.length > 0) {
                stuDevice = devices[0];
                localStorage.setItem("stuDevice", JSON.stringify({
                    "vendorId": stuDevice.vendorId,
                    "productName": stuDevice.productName,
                    "productId": stuDevice.productId
                }));
            } else {
                throw "No STU devices found";
            }
        } else {
            stuDevice = JSON.parse(stuDeviceStr);
            // get all the devices that we have permissions to connect
            await navigator.hid.getDevices().then(devices => {
                devices.forEach(device => {
                    if (stuDevice.vendorId === device.vendorId && stuDevice.productId === device.productId && stuDevice.productName === device.productName) {
                        stuDevice = device;
                    }
                });
            });
        }

        config.stuDevice = stuDevice;
        stuCapDialog = new StuCaptDialog(config);
        stuCapDialog.addEventListener("ok", function () {
            renderSignature();
        });

        //in this demo we use https://github.com/keithws/browser-report library for getting
        //information about the os.
        const webBrowserData = browserReportSync();
        const osInfo = webBrowserData.os.name + " " + webBrowserData.os.version;
        const nicInfo = "";
        const where = "";

        const signatureFirstName = document.getElementById("signatureFirstName");
        const signatureLastName = document.getElementById("signatureLastName");
        const signatureIdnp = document.getElementById("signatureIdnp");

        const signatureAuthorInfo = `${signatureLastName.innerHTML} ${signatureFirstName.innerHTML}`;

        stuCapDialog.open(
            mSigObj,
            "",
            "",
            where,
            Module.KeyType.SHA512,
            documentHash,
            osInfo,
            nicInfo,
            signatureAuthorInfo
        );
    }

    function setDeviceName() {
        const stuDeviceStr = localStorage.getItem("stuDevice");
        if (stuDeviceStr) {
            document.getElementById("selectedStuDevice").innerHTML = JSON.parse(stuDeviceStr).productName;
        } else {
            document.getElementById("selectedStuDevice").innerHTML = "None";
        }
    }

    function removeDevice() {
        localStorage.removeItem("stuDevice");
    }

    function clear() {
        if (stuCapDialog) {
            stuCapDialog.clear();
        }

        if (sigCaptDialog) {
            sigCaptDialog.clear();
        }
    }

    function cancel() {
        if (stuCapDialog) {
            stuCapDialog.cancel();
        }

        if (sigCaptDialog) {
            sigCaptDialog.cancel();
        }
    }

    function accept() {
        if (stuCapDialog) {
            stuCapDialog.accept();
        }

        if (sigCaptDialog) {
            if (stuCapDialog) {
                sigCaptDialog.cancel();
            } else {
                sigCaptDialog.accept();
            }

        }
    }

    function mmToPx(mm) {
        var dpr = window.devicePixelRatio;
        var inch = 25.4; //1inch = 25.4 mm
        var ppi = 96;
        return ((mm / inch) * ppi) / dpr;
    }

    function pxToMm(px) {
        var dpr = window.devicePixelRatio;
        var inch = 25.4; //1inch = 25.4 mm
        var ppi = 96;
        return ((px * dpr) / ppi) * inch;
    }

    function pxToInches(px) {
        return px / 96;
    }

    async function renderSignatureImage() {
        // calculate the size
        let renderWidth = 400;
        let renderHeight = 300;
        const isRelative = true;

        let renderFlags = 0x400000;
        if (isRelative) {
            renderFlags |= 0x2000000;
            const sx = (96 / 25.4) * 2;
            renderWidth = Math.floor(mmToPx(mSigObj.getWidth(true) / 100) + sx);
            renderHeight = Math.floor(mmToPx(mSigObj.getHeight(true) / 100) + sx);
        } else {
            if (isNaN(renderWidth) || renderWidth <= 0) {
                if (isNaN(renderHeight) || renderHeight <= 0) {
                    // it takes the original size
                    renderWidth = mmToPx(mSigObj.getWidth(false) / 100);
                    renderHeight = mmToPx(mSigObj.getHeight(false) / 100);
                } else {
                    // it takes the size proportional to the height
                    const originalRenderWidth = mmToPx(mSigObj.getWidth() / 100);
                    const originalRenderHeight = mmToPx(mSigObj.getHeight() / 100);
                    renderWidth = (originalRenderWidth / originalRenderHeight) * renderHeight;
                }
            } else if (isNaN(renderHeight) || renderHeight <= 0) {
                // it takes the size proportinal to the width
                const originalRenderWidth = mmToPx(mSigObj.getWidth() / 100);
                const originalRenderHeight = mmToPx(mSigObj.getHeight() / 100);
                renderHeight = (originalRenderHeight / originalRenderWidth) * renderWidth;
            }

            renderWidth = Math.floor(renderWidth);
            renderHeight = Math.floor(renderHeight);
            renderWidth += renderWidth % 4;
        }

        const backgroundColor = "#ffffff";

        if (isRelative) {
            renderWidth = -96; //dpi
            renderHeight = -96;
        }

        const inkColor = "#0202FE";
        const inkWidth = 6;
        const image = await mSigObj.renderBitmap(renderWidth, renderHeight, "image/png", inkWidth, inkColor, backgroundColor, 0, 0, renderFlags);
        return image;
    }

    async function renderSignature() {
        const image = await renderSignatureImage();

        document.getElementById("captureDiv").style.display = "none"
        document.getElementById("signatureImage").src = image;
        document.getElementById("signatureImage").style.display = "block";
    }

    let dataForVoterUpdating = {};

    async function saveSignature() {
        if (!allowSaveSignature) {
            return;
        }

        await accept();

        dataForVoterUpdating = {
            VoterId: $('#signatureDialog').attr('data-voter-id'),
            ElectionId: $('#signatureDialog').data("electionId"),
            AssignedVoterId: $('#signatureDialog').attr("data-assigned-voter-id"),
            VoterStatus: $('#signatureDialog').data("voterStatus"),
            AssignedVoterStatus: $('#signatureDialog').data("assignedVoterStatus")
        };

        const updateVoterData = JSON.stringify({ updateData: dataForVoterUpdating });

        await $.ajax({
            url: '@Url.Action("UpdateVoter")',
            type: 'post',
            dataType: 'json',
            contentType: 'application/json',
            data: updateVoterData,
            success: function (result) {
                if (!result.Success) {
                    //todo: message arrea update for failure required

                    console.error("Error", result);

                    return;
                }
            }
        });

        setTimeout(() => {
            const newLink = document.createElement("a");
            newLink.href = document.getElementById("signatureImage").src;
            newLink.click();

            const imageUrl = document.getElementById("signatureImage").src;

            fetch(imageUrl)
                .then(response => response.blob())
                .then(blob => {
                    newLink.href = URL.createObjectURL(blob);

                    const signatureIdnp = document.getElementById("signatureIdnp").innerHTML;
                    const formData = new FormData();

                    formData.append('file', blob, 'signature.png');
                    formData.append('idnp', signatureIdnp);

                    $.ajax({
                        url: '/Voting/CaptureSignature',
                        type: 'POST',
                        data: formData,
                        contentType: false,
                        processData: false,
                        enctype: 'multipart/form-data',
                        success: function (response) {
                            console.log('Signature saved successfully:', response);

                            window.location.href = `/Voting?idnp=${signatureIdnp}`;
                        },
                        error: function (error) {
                            console.error('Error saving signature:', error);
                        }
                    });

                    // Optionally, revoke the object URL after use to free up memory
                    URL.revokeObjectURL(newLink.href);
                })
                .catch(error => {
                    console.error('Error fetching image:', error);
                });

            $('#signatureDialog').modal('hide');
        }, 500);
    }


    async function addDocumentHash() {
        const reader = new FileReader();
        reader.onload = async function () {
            try {
                documentHash.delete();
                const data = reader.result;
                const hashType = Module.HashType.SHA512;
                documentHash = new Module.Hash(hashType);
                var enc = new TextEncoder(); // always utf-8
                if (await documentHash.add(data)) {
                    alert("Document bounded properly");
                } else {
                    alert("Document fails to bound");
                }
            } catch (e) {
                alert(e);
            }
        }
        reader.readAsArrayBuffer(document.getElementById("document").files[0]);
    }

    function openTab(evt, tabName) {
        // Get all elements with class="tabcontent" and hide them
        var tabcontent = document.getElementsByClassName("tabcontent");
        for (var i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }

        // Get all elements with class="tablinks" and remove the class "active"
        var tablinks = document.getElementsByClassName("tablinks");
        for (var i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }

        // Show the current tab, and add an "active" class to the button that opened the tab
        document.getElementById(tabName).style.display = "block";
        evt.currentTarget.className += " active";
    }

    async function loadSignature() {
        try {
            //reset encryption data
            await mSigObj.setPublicKey("");
            await mSigObj.setPrivateKey("");
            await mSigObj.setEncryptionPassword("");
            await decryptSignature(mSigObj);
        } catch (e) {
            console.log(e);
        }
        const file = document.getElementById("load_signature").files[0];
        if (file) {
            // check the type
            if (("text/plain" == file.type) || ("text/xml" == file.type)) {
                // read the file as string
                const reader = new FileReader();
                reader.onload = async function () {
                    const data = reader.result;
                    //try {
                    if ("text/plain" == file.type) {
                        if ((!await mSigObj.setTextData(data)) ||
                            (!await readSignature(false))) {
                            // maybe ISO binary text encrypted
                            try {
                                const ad = new Module.AdditionalImportIsoData();
                                ad.setWho("User imported from ISO");
                                ad.setWhy("Signature imported from ISO");
                                //ad.setWhen(new Date());
                                await mSigObj.importIso(data, Module.IsoType["ISO-19794-7_ENCRYPTED_TEXT"], ad);
                                readSignature(true);
                            } catch (e) {
                                alert(e);
                            }
                        }
                    } else {
                        //text/xml
                        const ad = new Module.AdditionalImportIsoData();
                        ad.setWho("User imported from XML ISO");
                        ad.setWhy("Signature imported from XML ISO");

                        const domParser = new DOMParser();
                        const xmlDocument = domParser.parseFromString(data, "text/xml");
                        const elements = xmlDocument.getElementsByTagName("CreationDate");
                        if (elements.length > 0) {
                            ad.setWhen(new Date(elements[0].innerHTML));
                        }

                        await mSigObj.importIso(data, Module.IsoType["ISO-19785-3_XML"], ad);
                        readSignature(true);
                    }
                    //} catch (e) {
                    //alert.log(e);
                    //}
                }
                reader.readAsText(file);
            } else if (file.type == "image/png") {
                const reader = new FileReader();
                reader.onload = async function () {
                    const data = reader.result;
                    var img = new Image();
                    img.addEventListener('load', async function () {
                        //the image has been loaded
                        const canvas = document.createElement("canvas");
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext("2d");
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        const imageData = ctx.getImageData(0, 0, img.width, img.height);
                        try {
                            await mSigObj.readEncodedBitmapBinary(imageData.data, imageData.width, imageData.height);
                            readSignature(true);
                        } catch (e) {
                            alert.log(e);
                        }
                    }, false);
                    img.src = data;
                }
                reader.readAsDataURL(file);
            } else {
                // we assume is binary data
                const reader = new FileReader();
                reader.onload = async function () {
                    const data = reader.result;
                    try {
                        if ((!await mSigObj.setSigData(new Uint8Array(data))) ||
                            (!await readSignature(false))) {
                            // try with iso format
                            const ad = new Module.AdditionalImportIsoData();
                            ad.setWho("User imported from ISO");
                            ad.setWhy("Signature imported from ISO");

                            if (await mSigObj.importIso(new Uint8Array(data), isEncryptedBinary(data) ? Module.IsoType['ISO-19794-7_ENCRYPTED_BINARY'] : Module.IsoType['ISO-19794-7_BINARY'], ad)) {
                                readSignature(true);
                            } else {
                                alert("Incorrect signature data found");
                                emptyLoadData();
                            }
                        }
                    } catch (e) {
                        alert(e);
                        emptyLoadData();
                    }
                }
                reader.readAsArrayBuffer(file);
            }
        }
    }

    function emptyLoadData() {
        document.getElementById("load_who").innerHTML = "";
        document.getElementById("load_why").innerHTML = "";
        document.getElementById("load_when").innerHTML = "";
        document.getElementById("load_extra_data").innerHTML = "";

        document.getElementById("load_digitizer_type").innerHTML = "";
        document.getElementById("load_digitizer_driver").innerHTML = "";
        document.getElementById("load_operating_system").innerHTML = "";
        document.getElementById("load_network_interface_card").innerHTML = "";
        document.getElementById("load_licence").innerHTML = "";

        document.getElementById("load_integrity").innerHTML = "";

        document.getElementById("document_load").disabled = true;
        document.getElementById("signatureImage_loaded").style.display = "none";
        document.getElementById("signatureimage_loaded_background").style.display = "block";
    }

    async function readSignature(showError) {
        try {
            const image = await renderSignatureImage();

            document.getElementById("load_who").innerHTML = mSigObj.getWho();
            document.getElementById("load_why").innerHTML = mSigObj.getWhy();
            let when = mSigObj.getWhen();
            document.getElementById("load_when").innerHTML = "The signature was captured on " + when;
            document.getElementById("load_extra_data").innerHTML = mSigObj.getExtraData("");

            document.getElementById("load_digitizer_type").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Digitizer);
            document.getElementById("load_digitizer_driver").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Digitizer_Driver);
            document.getElementById("load_operating_system").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Machine_OS);
            document.getElementById("load_network_interface_card").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Network_Card);
            document.getElementById("load_licence").innerHTML = mSigObj.getLicence();

            const types = [Module.KeyType.MD5,
            Module.KeyType.SHA1,
            Module.KeyType.SHA224,
            Module.KeyType.SHA256,
            Module.KeyType.SHA384,
            Module.KeyType.SHA512];

            for (let i = 0; i < types.length; i++) {
                try {
                    let status = await mSigObj.checkIntegrity(types[i]);
                    if (status == Module.IntegrityStatus.OK) {
                        document.getElementById("load_integrity").innerHTML = '<span style="color:green">The signature integrity is correct.</span>';
                        break;
                    } else if (status == Module.IntegrityStatus.MISSING) {
                        document.getElementById("load_integrity").innerHTML = '<span style="color:black">No Integrity data found.</span>';
                        break;
                    } else if (status != Module.IntegrityStatus.WRONG_TYPE) {
                        document.getElementById("load_integrity").innerHTML = '<span style="color:red">' + integrityStatusDesc(status) + '</span>';
                        break;
                    }
                } catch (e) {
                }
            }

            document.getElementById("document_load").disabled = false;

            document.getElementById("signatureImage_loaded").src = image;
            document.getElementById("signatureImage_loaded").style.display = "block";
            document.getElementById("signatureimage_loaded_background").style.display = "none";
        } catch (e) {
            if (showError) {
                alert(e);
            }
            return false;
        }

        return true;
    }

    async function checkDocumentHash() {
        const reader = new FileReader();
        reader.onload = async function () {
            try {
                const data = reader.result;

                const types = [Module.KeyType.MD5,
                Module.KeyType.SHA1,
                Module.KeyType.SHA224,
                Module.KeyType.SHA256,
                Module.KeyType.SHA384,
                Module.KeyType.SHA512];

                for (let i = 0; i < types.length; i++) {
                    const hashType = types[i];
                    let documentHash = new Module.Hash(hashType);
                    if (await documentHash.add(data)) {
                        const status = await mSigObj.checkSignedData(documentHash);
                        if (status != Module.DataStatus.BAD_TYPE) {
                            alert(dataStatusDesc(status));
                            break;
                        }
                    } else {
                        alert("Failed to load file");
                        break;
                    }
                    documentHash.delete();
                }
            } catch (e) {
                alert(e);
            }
        }
        reader.readAsArrayBuffer(document.getElementById("document_load").files[0]);
    }

    function loadBackgroundImage() {
        const file = document.getElementById("background_image").files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = async function () {
                const data = reader.result;
                backgroundImage = new Image();
                backgroundImage.src = data;
            }
            reader.readAsDataURL(file);
        }
    }

    function removeButton(button) {
        document.getElementById(button).remove();
    }

    function addButton() {
        const newDiv = document.createElement("div");
        const btnDiv = "btn_div_" + new Date().getTime();
        let content = '<fieldset id="' + btnDiv + '"><p>' +
            '<label for="button_text">Button Text:</label>' +
            '<input type="text" name="button_text"></p>' +
            '<p><label for="button_action">Action:</label>' +
            '<input type="text" name="button_action"></p>' +
            '<p><label for="button_text_color">Text color:</label>' +
            '<input type="color" name="button_text_color" value="#000000"></p>' +
            '<p><label for="button_background_color">Background color:</label>' +
            '<input type="color" name="button_background_color" value="#e7e7e7"></p>' +
            '<p><label for="button_border_with">Border width:</label>' +
            '<input type="text" name="button_border_width" value="1"></p>' +
            '<p><label for="button_border_color">Border color:</label>' +
            '<input type="color" name="button_border_color" value="#cccccc"></p>' +
            '<p><button onClick="removeButton(\'' + btnDiv + '\')">Remove</button></p>' +
            '</fieldset>';

        newDiv.innerHTML = content;
        document.getElementById("button_list_div").appendChild(newDiv);
    }

    function addExtraData() {
        const newDiv = document.createElement("div");
        const extraDiv = "extra_data_div_" + new Date().getTime();
        let content = '<fieldset id="' + extraDiv + '">' +
            '<label for="extra_name_text">Name:</label>' +
            '<input type="text" name="extra_name">' +
            '<br><br><label for="extra_value">Value:</label>' +
            '<input type="text" name="extra_value">' +
            '<br><br>' +
            '<button onClick="removeExtraData(\'' + extraDiv + '\')">Remove</button>' +
            '</fieldset>';

        newDiv.innerHTML = content;
        document.getElementById("extra_data_list_div").appendChild(newDiv);
    }

    function removeExtraData(extraData) {
        document.getElementById(extraData).remove();
    }

    function generateExtraData() {
        const extraData = [];
        const list = document.getElementById("extra_data_list_div");
        const fields = list.getElementsByTagName("fieldset");
        for (var i = 0; i < fields.length; i++) {
            extraData.push({
                name: fields[i].elements.namedItem("extra_name").value,
                value: fields[i].elements.namedItem("extra_value").value
            }
            );
        }

        return extraData;
    }

    async function encryptSignature() {
        try {
            if (document.getElementById("no_encryption").checked) {
                await mSigObj.setPublicKey("");
                await mSigObj.setPrivateKey("");
            } else {
                if (document.getElementById("symmetric_encryption").checked) {
                    await mSigObj.setEncryptionPassword(document.getElementById("symmetric_password").value);
                } else if (document.getElementById("asymmetric_encryption").checked) {
                    const pubKey = document.getElementById("public_key").value;
                    if (pubKey !== "") {
                        await mSigObj.setPublicKey(pubKey);
                    }
                }

                if (!mSigObj.canEncrypt()) {
                    alert("The signature cannot be encrypted");
                }
            }
        } catch (e) {
            alert(e);
        }
    }

    async function decryptSignature(signature) {
        try {
            if (document.getElementById("symmetric_encryption").checked) {
                await signature.setEncryptionPassword(document.getElementById("symmetric_password").value);
            } else if (document.getElementById("asymmetric_encryption").checked) {
                const privKey = document.getElementById("private_key").value;
                if (privKey !== "") {
                    const privKeyPassword = document.getElementById("private_key_password").value;
                    if (privKeyPassword !== "") {
                        // add the password to the end of the key
                        privKey += "," + privKeyPassword;
                    }
                    await signature.setPrivateKey(privKey);
                }
            }
        } catch (e) {
            alert(e);
        }
    }

    function resign() {
        const saveSignatureBtn = document.querySelector("#saveSignatureBtn");
        saveSignatureBtn.setAttribute("disabled", "disabled");
        allowSaveSignature = false;

        clear();
    }
</script>

<script>
    let intervalId;

    function startModalCountdown() {
        const modalFooter = document.querySelector(".modal-footer");
        const warningMessage = document.createElement("p");

        warningMessage.innerHTML = "Atenție! Fereastra modală se va închide în <span id='countdown' style='font-weight: 700;'>60</span> de secunde.";
        warningMessage.classList.add("warning-message");
        modalFooter.prepend(warningMessage);

        let secondsCount = 60;

        intervalId = setInterval(() => {
            document.getElementById('countdown').innerHTML = secondsCount;

            secondsCount -= 1;

            if (secondsCount < 0) {
                clearInterval(intervalId);

                $('#signatureDialog').modal('hide');

                $('#signatureExpirationDialog').modal('show');
            }
        }, 1000);
    }

    $('#signatureDialog').on('hidden.bs.modal', function () {
        dataForVoterUpdating = {};
        clearInterval(intervalId);
        document.querySelector(".warning-message").remove();
        cancel();
    });

    $('#signatureDialog').on('shown.bs.modal', function () {
        initializeSignatureCapturingModule();
    });
</script>
